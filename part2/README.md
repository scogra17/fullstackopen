# Notes
## Creating snippets for VSCode
* [Docs](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets)
* Opening the command palette: `cmd + t`

## Keys
* React uses the key attribute of objects in an array to determine how to update the view generated by a component when the component is re-rendered. More details [here](https://reactjs.org/docs/reconciliation.html#recursing-on-children)

## JSON server
* Define lightweight "server"
* Steps
  1) Define 'db.json'
  2) `$ npx json-server --port 3001 --watch db.json`

## Async model
* [MDN resource - event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
* JavaScript engines, or runtime environments, follow the asynchronous model. In principle, this requires all IO-operations (with some exceptions) to be executed as non-blocking. This means that the code execution continues immediately after calling an IO function, without waiting for it to return.
* Currently, JavaScript engines are single-threaded, which means that they cannot execute code in parallel. As a result, it is a requirement in practice to use a non-blocking model for executing IO operations. Otherwise, the browser would "freeze" during, for instance, the fetching of data from a server.

## NPM
* install package for project only. From root of project: `$ npm install [pkg name]`
  * runtime dependency of the application, because the execution of the program requires the existence of the library
* install dependency for development only: `npm install [pkg name] --save-dev`
  * development dependency (--save-dev), since the program itself doesn't require it. It is used for assistance during software development.

## Effect hooks
* The Effect Hook lets you perform side effects in function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.
* By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.
* The second parameter of useEffect is used to specify how often the effect is run. If the second parameter is an empty array [], then the effect is only run along with the first render of the component.

```javascript
const App = () => {
  const [notes, setNotes] = useState([])
  const [newNote, setNewNote] = useState('')
  const [showAll, setShowAll] = useState(true)

  useEffect(() => {  // called after rendering is complete
    console.log('effect')
    axios
      .get('http://localhost:3001/notes')
      .then(response => {
        console.log('promise fulfilled')
        setNotes(response.data) //  a call to a state-updating function triggers the re-rendering of the component.
      })
  }, [])
  console.log('render', notes.length, 'notes')
  // ...
```

## Managing API key
* You need an api-key to use almost every weather service. Do not save the api-key to source control! Nor hardcode the api-key to your source code. Instead use [an environment variable to save the key](https://create-react-app.dev/docs/adding-custom-environment-variables/).
* e.g. when starting app `$ REACT_APP_API_KEY='t0p53cr3t4p1k3yv4lu3' npm start`
  * and then access via:
  ```javascript
  const api_key = process.env.REACT_APP_API_KEY
  // variable api_key has now the value set in startup
  ```
* Note that if you created the application using npx create-react-app ...and you want to use a different name for your environment variable then the environment variable name must still begin with REACT_APP_. You can also use a .envfile rather than defining it on the command line each time by creating a file entitled '.env' in the root of the project and adding the following.

## REST
* We refer to individual data objects, such as the notes in our application, as resources, each of which has a unique address associated with it - its URL.
* Individual notes stored in the json-server backend can be modified in two different ways by making HTTP requests to the note's unique URL. We can either replace the entire note with an HTTP PUT request, or only change some of the note's properties with an HTTP PATCH request.

## Promises
* The catch method can be used to define a handler function at the end of a promise chain, which is called once any promise in the chain throws an error and the promise becomes rejected, e.g.:

```javascript
axios
  .put(`${baseUrl}/${id}`, newObject)
  .then(response => response.data)
  .then(changedNote => {
    // ...
  })
  .catch(error => {
    console.log('fail')
  })
```

## Styling
* In React we have to use the className attribute instead of the class attribute.
* Defining styles inline, e.g.:
```javascript
const Footer = () => {
  const footerStyle = {
    color: 'green',
    fontStyle: 'italic',
    fontSize: 16
  }
  return (
    <div style={footerStyle}>
      <br />
      <em>Note app, Department of Computer Science, University of Helsinki 2022</em>
    </div>
  )
}

const App = () => {
  // ...

  return (
    <div>
      <h1>Notes</h1>

      <Notification message={errorMessage} />

      // ...

      <Footer />
    </div>
  )
}
```
