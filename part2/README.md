# Notes
## Creating snippets for VSCode
* [Docs](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets)
* Opening the command palette: `cmd + t`

## Keys
* React uses the key attribute of objects in an array to determine how to update the view generated by a component when the component is re-rendered. More details [here](https://reactjs.org/docs/reconciliation.html#recursing-on-children)

## JSON server
* Define lightweight "server"
* Steps
  1) Define 'db.json'
  2) `$ npx json-server --port 3001 --watch db.json`

## Async model
* [MDN resource - event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
* JavaScript engines, or runtime environments, follow the asynchronous model. In principle, this requires all IO-operations (with some exceptions) to be executed as non-blocking. This means that the code execution continues immediately after calling an IO function, without waiting for it to return.
* Currently, JavaScript engines are single-threaded, which means that they cannot execute code in parallel. As a result, it is a requirement in practice to use a non-blocking model for executing IO operations. Otherwise, the browser would "freeze" during, for instance, the fetching of data from a server.

## NPM
* install package for project only. From root of project: `$ npm install [pkg name]`
  * runtime dependency of the application, because the execution of the program requires the existence of the library
* install dependency for development only: `npm install [pkg name] --save-dev`
  * development dependency (--save-dev), since the program itself doesn't require it. It is used for assistance during software development.

## Effect hooks
* The Effect Hook lets you perform side effects in function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.
* By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.
* The second parameter of useEffect is used to specify how often the effect is run. If the second parameter is an empty array [], then the effect is only run along with the first render of the component.

```javascript
const App = () => {
  const [notes, setNotes] = useState([])
  const [newNote, setNewNote] = useState('')
  const [showAll, setShowAll] = useState(true)

  useEffect(() => {  // called after rendering is complete
    console.log('effect')
    axios
      .get('http://localhost:3001/notes')
      .then(response => {
        console.log('promise fulfilled')
        setNotes(response.data) //  a call to a state-updating function triggers the re-rendering of the component.
      })
  }, [])
  console.log('render', notes.length, 'notes')
  // ...
```